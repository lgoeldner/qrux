(do

(defmacro! export-all! ()
	`(export! (reflect:defsym)))

(defmacro! defun! (ident args body)
	`(val! ,ident (fn* ,args ,body)))

(defmacro! when (c &rest)
	`(if ,c (do ~rest)))

(defmacro! let (b e)
	`((fn*
        ,(map car b) ,e) 
        ~(map cadr b)))

(defun! t= (a b)
    (= (typeof a) (typeof b)))

(defmacro! cut (&rest)
	`(fn* (<>) ,rest))

(defmacro! and (lhs rhs)
	`(if ,lhs
		(if ,rhs
			true
			false)
		false))

(defmacro! or (lhs rhs)
	`(if ,lhs
		true
		(if ,rhs
			true
			false)))

(defun! rep (str)
	(eval
		(read-string (del! str))))

; load a file and execute it with a do block wrapped around
(defun! loadf (path)
		(rep
			(str 
				"(do\n" 
				(slurp (str path))
				"\n)")))

(defmacro! fn (form)
  `(fn* () ,form))

; swaps the order of two arguments
(defun! flip (func) 
	(fn* (a b) (func b a)))

(defun! append (el to)
	(concat to (list el)))

(defun! nil? (it)
	(= nil it))

(val! lt <)
(val! gt >)
(val! eq =)

(defmacro! assert (cond)
	`(if (= ,cond true)
		nil ; nil if the assertion holds
		(throw 
			(str "Assertion Failed: " ',cond))))

(defmacro! assert-or (cond error)
	`(if (= ,cond true)
		nil ; nil if the assertion holds
		(throw error))) ; else throw the error

(defun! unwrap (it)
	(if (= nil it)
		(throw "Non-nil Assertion failed!")
		it))

(defun! todo (message)
	(throw (str "Not yet implemented: " message)))

(defmacro! cond (&rest)
	(let*  (first (car rest)
			condition (car first)
			expr (nth 1 first)
			next (cdr rest))
			`(if ,condition
				,expr
				,(if next
					(cons 'cond next)
					nil))))

(defun! dbg (it)
	(do
		(prn it)
		it))

(defun! range (to (from 0) (acc ()))
	(if (< from to)
		(range to :from (+ from 1) :acc (cons from acc))
		(rev acc)))

(defmacro! newenv (&rest)
	`((fn* () (do ~rest))))

(defun! cadr (it)
	(car (cdr it)))

(defun! timeit (it)
	(let* (
		now (time)
		res (it)
		elapsed (- (time) now)
		_ (println (str "Result: " it " took " elapsed "ms")))

		res))

(defmacro! timed (it)
	`(timeit (fn* () ,it)))

(defun! map (f over (acc '()))
  (if (empty? over)
    (rev acc)
    (map 
      f 
      :over (cdr over) 
      :acc (cons (f (car over)) acc))))

(defun! loadf-exported (path)
	(eval (read-string (str "(do " (slurp path) "(*ENV*)" " (export! (reflect:defsym)))"))))

(defmacro! list:iter (ident in lst &rest)
	(do 
		(assert (= in 'in))
	   `(map (fn* (,ident) (do ~rest)) ,lst)))

(defmacro! set! (ident val)
	`(do (del! ,ident) (val! ,ident ,val)))

(defun! str:substr (s (from 0) (to (str:len s)))
	(str:_substr s from to))

(list:iter file in *ARGS*
		(println (str "loading file: " (car *ARGS*)))
		(try* (loadf (car *ARGS*))
			(catch* ex (println (str "failed to load `"file"`: " ex)))))

)