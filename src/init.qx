(do

(val! t true)
(val! f false)

(defmacro! defun! (ident args body)
	`(val! ,ident (fn* ,args ,body)))

(defmacro! when (cond &body)
	`(if ,cond (do ~body)))

;;; Boolean Operators
(defun! not (bool)
	(if bool
		false
		true))

; macro for short circuiting
(defmacro! and (lhs rhs)
	`(if ,lhs
		(if ,rhs
			true
			false)
		false))

(defmacro! or (lhs rhs)
	`(if ,lhs
		false
		(if ,rhs
			true
			false)))

(val! | or)
(val! & and)
(val! ! not)

(defun! rep (str)
	(eval
		(read-string str)))

; load a file and execute it with a do block wrapped around
(defun! loadf (path)
	(rep
		(str 
			"(do" 
			(slurp path)
			")")))

; returns a curried function
; swaps the order of two arguments
(defun! swap (func) (fn* (a b) (func b a)))

(defun! append (el to)
	(concat to (list el)))

(defun! nil? (it)
	(= nil it))

(val! lt <)
(val! gt >)
(val! eq =)

(defmacro! := (atom set_to)
	`(do (reset! ,atom ,set_to) nil))


(defmacro! assert (cond)
	`(if (= ,cond true)
		nil ; Nothing if the assertion holds
		(throw 
			(str "Assertion Failed: " ',cond))))


(defmacro! assert-or (cond error)
	`(if (= ,cond true)
		nil ; Nothing if the assertion holds
		(throw 
			error)))

(defmacro! unwrap (it)
	`(if (= nil ,it)
		(throw "Non-nil Assertion failed!")
		,it
		))

(val! .. slice)
)
