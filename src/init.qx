(do


(val! t true)
(val! f false)

(defmacro! defun! (ident args body)
	`(val! ,ident (fn* ,args ,body)))

(defmacro! when (cond &body)
	`(if ,cond (do ~body)))

;;; Boolean Operators
(defun! not (bool)
	(if bool
		false
		true))

; macro for short circuiting
(defmacro! and (lhs rhs)
	`(if ,lhs
		(if ,rhs
			true
			false)
		false))

(defmacro! or (lhs rhs)
	`(if ,lhs
		false
		(if ,rhs
			true
			false)))

(val! | or)
(val! & and)
(val! ! not)

(defun! rep (str)
	(eval
		(read-string str)))

; load a file and execute it with a do block wrapped around
(defun! loadf (path)
	(rep
		(str 
			"(do" 
			(slurp path)
			")")))

; returns a curried function
; swaps the order of two arguments
(defun! swap (func) (fn* (a b) (func b a)))

(defun! append (el to)
	(concat to (list el)))

(defun! nil? (it)
	(= nil it))

(val! lt <)
(val! gt >)
(val! eq =)

(defmacro! := (atom set_to)
	`(do (reset! ,atom ,set_to) nil))

(defmacro! assert (cond)
	`(if (= ,cond true)
		nil ; nil if the assertion holds
		(throw 
			(str "Assertion Failed: " ',cond))))

(defmacro! assert-or (cond error)
	`(if (= ,cond true)
		nil ; nil if the assertion holds
		(throw error))) ; else throw the error

(defmacro! unwrap (it)
	`(if (= nil ,it)
		(throw "Non-nil Assertion failed!")
		,it))

(defun! try-nil (expr)
	(try* expr (catch* _ nil)))

(val! .. slice)

(defun! todo (message)
	(throw (str "Not yet implemented: " message)))

(defmacro! cond (&args)
	(let* (
			head (car args)
			condition (car head)
			expr (nth 1 head)
			next (cdr args)
		)
			(if next
				`(if ,condition
						,expr
						,(cons 'cond next)
						;; dont know why it needs the cons instead of (cond ~next)
						) 
				nil)))


(if (= 1 (count *ARGS*))
	(loadf (car *ARGS*))))
