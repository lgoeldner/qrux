(do

(defmacro! export-all! ()
	`(export! (reflect:defsym)))

(defmacro! defun! (ident args body)
	`(val! ,ident (fn* ,args ,body)))

(defmacro! when (cond &body)
	`(if ,cond (do ~body)))

(defmacro! let (b e)
	`((fn*
        ,(map car b) ,e) 
        ~(map cadr b)))

(defun! t= (a b)
    (= (typeof a) (typeof b)))

;;; Boolean Operators
(defun! not (bool)
	(if bool
		false
		true))

; macro for short circuiting
(defmacro! and (lhs rhs)
	`(if ,lhs
		(if ,rhs
			true
			false)
		false))

(defmacro! or (lhs rhs)
	`(if ,lhs
		true
		(if ,rhs
			true
			false)))

(val! | or)
(val! & and)
(val! ! not)

(defun! rep (str)
	(eval
		(read-string (del! str))))

; load a file and execute it with a do block wrapped around
(defun! loadf (path)
	(rep
		(str 
			"(do\n" 
			(slurp path)
			"\n)")))

; swaps the order of two arguments
(defun! flip (func) (fn* (a b) (func b a)))

(defun! append (el to)
	(concat to (list el)))

(defun! nil? (it)
	(= nil it))

(val! lt <)
(val! gt >)
(val! eq =)

(defmacro! assert (cond)
	`(if (= ,cond true)
		nil ; nil if the assertion holds
		(throw 
			(str "Assertion Failed: " ',cond))))

(defmacro! assert-or (cond error)
	`(if (= ,cond true)
		nil ; nil if the assertion holds
		(throw error))) ; else throw the error

(defun! unwrap (it)
	(if (= nil it)
		(throw "Non-nil Assertion failed!")
		it))

(defun! todo (message)
	(throw (str "Not yet implemented: " message)))

(defmacro! cond (&args)
	(let*  (first (car args)
			condition (car first)
			expr (nth 1 first)
			next (cdr args))
			`(if ,condition
				,expr
				,(if next
					(cons 'cond next)
					nil))))

(defun! dbg (it)
	(do
		(prn it)
		it))

(defun! _do-range (from to acc)
	(if (from \< to)
		(_do-range (from \+ 1) to (cons from acc))
		(rev acc)))

(defun! range (from to)
	(_do-range from to '()))

(defmacro! newenv (&to-do)
	`(let* () (do ~to-do)))

(defun! cadr (it)
	(car (cdr it)))

(defun! timeit (it)
	(let* (
		now (time)
		res (it)
		elapsed (- (time) now)
		_ (println (str "Result: " it " took " elapsed "ms")))

		res))

(defmacro! timed (it)
	`(timeit (fn* () ,it)))

(defun! _do_map (fun it acc)
	(if (empty? it)
		(rev acc)
		(_do_map 
			fun 
			(cdr it) 
			(cons (fun (car it)) 
			acc))))

(defun! map (fun it)
	(_do_map fun it ()))

(defun! loadf-exported (path)
	(eval (read-string (str "(do " (slurp path) "(*ENV*)" " (export! (reflect:defsym)))"))))

(defmacro! list:iter (ident in lst &body)
	(do 
		(assert (= in 'in))
	   `(map (fn* (,ident) (do ~body)) ,lst)))

(defmacro! set! (ident val)
	`(do (del! ,ident) (val! ,ident ,val)))

(list:iter file in *ARGS*
		(println (str "loading file: " (car *ARGS*)))
		(try* (loadf (car *ARGS*))
			(catch* ex (println (str "failed to load `"file"`: " ex)))))

)