(defun! enum (lst (acc ()) (from 0))
	(if (empty? lst)
		(rev acc)
		(enum (cdr lst) (cons (list from (car lst)) acc) (+ 1 from))))

(defun! skip (lst n)
	(if (= 0 n)
		lst
		(skip (cdr lst) (- n 1))))

(defun! fold (init fn over)
	(if (empty? over)
		init
		(fold 
			(fn init (car over))
			fn
			(cdr over))))

(defun! reduce (fn over)
	(fold (car over) fn (cdr over)))

(defun! zip (a b (acc ()))
	(if (or (empty? a) (empty? b))
		(rev acc)
		(zip 
			(cdr a) (cdr b)
			(cons (list (car a) (car b)) acc))))

;; into: function or incomplete expr
;; like: +, (+ 10), (cons '(1 2 3 4))
(defmacro! insertarg (this into)
  (if (list? into)
    (let 
      ((fun (car into)))
      (cons fun (cons this (cdr into))))
    (cons into this)))

(defun! cons* (&items onto)
  (if (empty? items)
    onto
    (cons* (cdr items) (cons (car items) onto))))

;; (-> a (b 2) (c 3 4))
;; => (c (b a 2) 3 4)
(defmacro! thread-list (v1 into)
  (if (empty? into)
    v1
    `(thread-list (insertarg ,v1 ,(car into)) ,(cdr into))))

(defmacro! -> (start &rest)
  `(thread-list ,start ,rest))

(export! 
'(fold
  reduce
  zip
  enum
  sum2
  skip
  ->
  thread-list
  insertarg
  cons*
  ))